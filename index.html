<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="码农说">
<meta property="og:url" content="http://manongtalk.com/index.html">
<meta property="og:site_name" content="码农说">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农说">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://manongtalk.com/"/>

  <title> 码农说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">码农说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一个程序员的日常</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-factory-compare/" itemprop="url">
                  工厂模式小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T21:53:20-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>分类</strong></p>
<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
<p>工厂模式可以分为三类：</p>
<p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p>
<p>这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。</p>
<p><strong>创建型模式</strong></p>
<p>前面介绍过的三种工厂模式在设计模式的分类中都属于创建型模式。</p>
<p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p>
<p><strong>工厂模式的优点</strong></p>
<p>工厂模式是创建型模式中比较重要的。<br>工厂模式的主要功能就是帮助我们实例化对象的。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。<br>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。</p>
<p><strong>三种工厂模式之间的演化与区别</strong></p>
<img src="/2016/09/04/2016-09-04-factory-compare/factory.png" alt="factory.png" title="">
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-abs-factory/" itemprop="url">
                  抽象工厂模式(Abstract Factory Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T21:36:43-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>工厂模式的简单回顾</strong></p>
<p>在介绍了简单工厂模式和工厂方法模式之后，相信很多人对工厂模式（如果单独提到工厂模式，即包括简单工厂模式、工厂方法模式及本文即将介绍的抽象工厂模式）的思想都有了一定的理解。这里我们在简单回顾一下。</p>
<p>工厂模式的主要功能就是帮助我们实例化对象的。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂方法代替new操作的。</p>
<p>这样做的好处是封装了对象的实例化细节，尤其是对于实例化较复杂或者对象的生命周期应该集中管理的情况。会给你系统带来更大的可扩展性和尽量少的修改量。</p>
<p><strong>简单工厂模式的优缺点</strong></p>
<p>优点：<br>1、屏蔽产品的具体实现，调用者只关心产品的接口。<br>2、实现简单</p>
<p>缺点：<br>1、增加产品，需要修改工厂类，不符合开放-封闭原则<br>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</p>
<p><strong>工厂方法模式的优缺点</strong></p>
<p>优点：<br>1、继承了简单工厂模式的优点<br>2、符合开放-封闭原则</p>
<p>缺点：<br>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<p>本文要介绍了抽象工厂模式，是在简单工厂模式和工厂方法模式的基础上衍生出的另外一种创建型设计模式。</p>
<p><strong>概念</strong></p>
<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<p><strong>产品族</strong></p>
<p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。</p>
<img src="/2016/09/04/2016-09-04-abs-factory/abstructFactory1.png" alt="产品族" title="产品族">
<p><strong>用途</strong></p>
<p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。</p>
<p>在以下情况下可以使用抽象工厂模式：</p>
<p>1)一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>2)系统中有多于一个的产品族，而每次只使用其中某一产品族。<br>3)属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>4)系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
<p><strong>实现方式</strong></p>
<p>抽象工厂模式包含如下角色：</p>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法</p>
<p>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；</p>
<p>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；</p>
<p>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
<p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。</p>
<img src="/2016/09/04/2016-09-04-abs-factory/abstructFactory2.png" alt="abstructFactory2.png" title="">
<p>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。</p>
<p>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public interface BenzCar &#123;</div><div class="line"></div><div class="line">    //加汽油</div><div class="line">    public void gasUp();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface TeslaCar &#123;</div><div class="line"></div><div class="line">    //充电</div><div class="line">    public void charge();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class BenzSportCar implements BenzCar &#123;</div><div class="line">    public void gasUp() &#123;</div><div class="line">        System.out.println(&quot;给我的奔驰跑车加最好的汽油&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BenzBusinessCar implements BenzCar&#123;</div><div class="line">    public void gasUp() &#123;</div><div class="line">        System.out.println(&quot;给我的奔驰商务车加一般的汽油&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TeslaSportCar implements TeslaCar &#123;</div><div class="line">    public void charge() &#123;</div><div class="line">        System.out.println(&quot;给我特斯拉跑车冲满电&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TeslaBusinessCar implements TeslaCar &#123;</div><div class="line">    public void charge() &#123;</div><div class="line">        System.out.println(&quot;给我特斯拉商务车冲满电&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是抽象工厂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface CarFactory &#123;</div><div class="line"></div><div class="line">    public BenzCar getBenzCar();</div><div class="line">    public TeslaCar getTeslaCar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是具体工厂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SportCarFactory implements CarFactory &#123;</div><div class="line">    public BenzCar getBenzCar() &#123;</div><div class="line">        return new BenzSportCar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TeslaCar getTeslaCar() &#123;</div><div class="line">        return new TeslaSportCar();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class BusinessCarFactory implements CarFactory &#123;</div><div class="line">    public BenzCar getBenzCar() &#123;</div><div class="line">        return new BenzBusinessCar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TeslaCar getTeslaCar() &#123;</div><div class="line">        return new TeslaBusinessCar();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>“开闭原则”的倾斜性</strong></p>
<p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p>
<p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p>
<p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<p><strong>三种工厂模式之间的关系</strong></p>
<p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p>
<p>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
<p><strong>总结</strong></p>
<p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-factory-method/" itemprop="url">
                  工厂方法模式(Factory Method Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T20:58:05-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>概念</strong></p>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
<p><strong>用途</strong></p>
<p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。</p>
<p>在以下情况下可以使用工厂方法模式：</p>
<p>1.一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
<p>2.一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
<p>3.将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p><strong>实现方式</strong></p>
<p>工厂方法模式包含如下角色：</p>
<p>Product：抽象产品（Operation）</p>
<p>ConcreteProduct：具体产品(OperationAdd)</p>
<p>Factory：抽象工厂(IFactory)</p>
<p>ConcreteFactory：具体工厂(AddFactory)</p>
<img src="/2016/09/04/2016-09-04-factory-method/factoryMethod.png" alt="工厂方法" title="工厂方法">
<p>这里还用计算器的例子。在保持Operation，OperationAdd，OperationDiv，OperationSub，OperationMul等几个方法不变的情况下，修改简单工厂模式中的工厂类（OperationFactory）。替代原有的那个”万能”的大工厂类，这里使用工厂方法来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//工厂接口</div><div class="line">public interface IFactory &#123;</div><div class="line">    Operation CreateOption();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//加法类工厂</div><div class="line">public class AddFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationAdd();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//除法类工厂</div><div class="line">public class DivFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationDiv();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//乘法类工厂</div><div class="line">public class MulFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationMul();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//减法类工厂</div><div class="line">public class SubFactory implements IFactory &#123;</div><div class="line"></div><div class="line">    public Operation CreateOption() &#123;</div><div class="line">        return new OperationSub();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IFactory factory = new AddFactory();</div><div class="line">        Operation operationAdd =  factory.CreateOption();</div><div class="line">        operationAdd.setValue1(10);</div><div class="line">        operationAdd.setValue2(5);</div><div class="line">        System.out.println(operationAdd.getResult());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一个工厂方法模式就已经写好了。</p>
<p>从代码量上看，这种工厂方法模式比简单工厂方法模式更加复杂。针对不同的操作（Operation）类都有对应的工厂。很多人会有以下疑问：</p>
<p><strong>貌似工厂方法模式比简单工厂模式要复杂的多？<br>工厂方法模式和我自己创建对象没什么区别？为什么要多搞出一些工厂来？</strong></p>
<p>下面就针对以上两个问题来深入理解一下工厂方法模式。</p>
<p><strong>工厂方法模式的利与弊</strong></p>
<p><strong>为什么要使用工厂来创建对象？</strong></p>
<p>封装对象的创建过程</p>
<p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>
<p><strong>为什么每种对象要单独有一个工厂？</strong></p>
<p>符合”开放-封闭原则”</p>
<p>主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p><strong>以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：</strong></p>
<p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<p><strong>工厂方法与简单工厂的区别</strong></p>
<p>工厂模式克服了简单工厂模式违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。<br>他们都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户端与产品对象的耦合。</p>
<p><strong>总结</strong></p>
<p>工厂方法模式是简单工厂模式的进一步抽象和推广。</p>
<p>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<p>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-simple-factory/" itemprop="url">
                  简单工厂 (Simple Factory)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T20:28:54-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>概念</strong></p>
<p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>值得注意的是，简单工厂模式并不属于23种GOF设计模式之一。但是他是抽象工厂模式，工厂方法模式的基础，并且也有广泛的应用。</p>
<p><strong>用途</strong></p>
<p>在介绍简单工厂模式之前，我们尝试解决以下问题：<br>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">// 计算类的基类</div><div class="line">public abstract class Operation &#123;</div><div class="line"></div><div class="line">    private double value1 = 0;</div><div class="line">    private double value2 = 0;</div><div class="line"></div><div class="line">    public double getValue1() &#123;</div><div class="line">        return value1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setValue1(double value1) &#123;</div><div class="line">        this.value1 = value1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public double getValue2() &#123;</div><div class="line">        return value2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setValue2(double value2) &#123;</div><div class="line">        this.value2 = value2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected abstract double getResule();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//加法</div><div class="line">public class OperationAdd extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() + getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//减法</div><div class="line">public class OperationSub extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() - getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//乘法</div><div class="line">public class OperationMul extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        return getValue1() * getValue2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//除法</div><div class="line">public class OperationDiv extends Operation &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected double getResule() &#123;</div><div class="line">        if (getValue2() != 0) &#123;</div><div class="line">            return getValue1() / getValue2();</div><div class="line">        &#125;</div><div class="line">        throw new IllegalArgumentException(&quot;除数不能为零&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        OperationAdd operationAdd = new OperationAdd();</div><div class="line">        operationAdd.setValue1(10);</div><div class="line">        operationAdd.setValue2(5);</div><div class="line">        System.out.println(operationAdd.getResule());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我需要执行减法运算时，我就要创建一个OperationSub类。也就是说，我想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的工厂类中。</p>
<p>简单工厂模式有以下优点：</p>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。</p>
<p>2、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>实现方式</strong></p>
<p>简单工厂模式其实和他的名字一样，很简单。先来看看它的组成:</p>
<p>1)工厂类角色:这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。（OperationFactory）</p>
<p>2)抽象产品角色:它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）</p>
<p>3)具体产品角色:工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
<img src="/2016/09/04/2016-09-04-simple-factory/simpleFactory.png" alt="简单工厂" title="简单工厂">
<p>在原有类的基础上，定义工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//工厂类</div><div class="line">public class OperationFactory &#123;</div><div class="line"></div><div class="line">    public static Operation createOperation(String operation) &#123;</div><div class="line">        Operation oper = null;</div><div class="line">        switch (operation) &#123;</div><div class="line"></div><div class="line">            case &quot;+&quot;:</div><div class="line">                oper = new OperationAdd();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;-&quot;:</div><div class="line">                oper = new OperationSub();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;*&quot;:</div><div class="line">                oper = new OperationMul();</div><div class="line">                break;</div><div class="line"></div><div class="line">            case &quot;/&quot;:</div><div class="line">                oper = new OperationDiv();</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                throw new UnsupportedOperationException(&quot;不支持该操作&quot;);</div><div class="line">        &#125;</div><div class="line">        return oper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Operation operationAdd = OperationFactory.createOperation(&quot;+&quot;);</div><div class="line">operationAdd.setValue1(10);</div><div class="line">operationAdd.setValue2(5);</div><div class="line">System.out.println(operationAdd.getResule());</div></pre></td></tr></table></figure>
<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<p><strong>简单工厂模式存在的问题</strong></p>
<p>在《设计模式概述》中介绍了设计模式一般应该遵循的几个原则。</p>
<p>下面我们从开闭原则(对扩展开放;对修改封闭)上来分析下简单工厂模式。当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承Operation类，其中实现平方的代码。除此之外我们还要修改OperationFactory类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。</p>
<p>我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。简单工厂可能就不太适用了。</p>
<p><strong>总结</strong></p>
<p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p>
<p>但是</p>
<p>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。</p>
<p>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p>
<p>这些缺点在工厂方法模式中得到了一定的解决。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-design-pattern-singleton/" itemprop="url">
                  单例模式（Singleton Pattern）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T16:25:20-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>概念</strong><br>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式。在 GOF 书中给出的定义为：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>用途</strong><br>单例模式有以下两个优点：</p>
<p>1.在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。<br>2.避免对资源的多重占用（比如写文件操作）。</p>
<p>有时候，我们在选择使用单例模式的时候，不仅仅考虑到其带来的优点，还有可能是有些场景就必须要单例。比如类似”一个党只能有一个主席”的情况。</p>
<p><strong>实现方式</strong><br>我们知道，一个类的对象的产生是由类构造函数来完成的。如果一个类对外提供了public的构造方法，那么外界就可以任意创建该类的对象。所以，如果想限制对象的产生，一个办法就是将构造函数变为私有的(至少是受保护的)，使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。</p>
<img src="/2016/09/04/2016-09-04-design-pattern-singleton/singleton_1.png" alt="单例模式" title="单例模式">
<p><strong>饿汉式</strong><br>下面是一个简单的单例的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//Singleton example : 饿汉式</div><div class="line">public class Singleton &#123;</div><div class="line">    //在类内部实例化一个实例</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line">    //私有的构造函数,外部无法访问</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">    //对外提供获取实例的静态方法</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是一个简单的单例的实现，这种实现方式我们称之为饿汉式。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton的实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。</p>
<p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。</p>
<p><strong>懒汉式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//Singleton example : 懒汉式</div><div class="line">public class Singleton &#123;</div><div class="line">    //定义实例</div><div class="line">    private static Singleton instance;</div><div class="line">    //私有构造方法</div><div class="line">    private Singleton()&#123;&#125;</div><div class="line">    //对外提供获取实例的静态方法</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        //在对象被使用的时候才实例化</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这种单例叫做懒汉式单例。懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。</p>
<p>有没有发现，其实这种懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。</p>
<p>针对线程不安全的懒汉式的单例，其实解决方式很简单，就是给创建对象的步骤加锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedSingleton &#123;</div><div class="line">    //定义实例</div><div class="line">    private static SynchronizedSingleton instance;</div><div class="line">    //私有构造方法</div><div class="line">    private SynchronizedSingleton()&#123;&#125;</div><div class="line">    //对外提供获取实例的静态方法,对该方法加锁</div><div class="line">    public static synchronized SynchronizedSingleton getInstance() &#123;</div><div class="line">        //在对象被使用的时候才实例化</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new SynchronizedSingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>枚举式</strong><br>在Java 1.5之前，实现单例一般只有以上几种办法，在Java 1.5之后，还有另外一种实现单例的方式，那就是使用枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum  Singleton &#123;</div><div class="line"></div><div class="line">    INSTANCE;</div><div class="line">    Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象可谓是很坚强的壁垒啊，在深度分析Java的枚举类型—-枚举的线程安全性及序列化问题中有详细介绍枚举的线程安全问题和序列化问题，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过，但是不代表他不好。</p>
<p><strong>总结</strong><br>本文中介绍了几种实现单例的方法，主要包括饿汉、懒汉、并发校验锁、枚举等。</p>
<p>从单例的实现中，我们可以发现，一个简单的单例模式就能涉及到这么多知识。单例模式其实如果再深入讨论，还可以涉及到序列化和多线程下的同步锁。</p>
<p>但是，在平时工作中，单例是需要慎用的。因为它造出的静态实例存在内存在不会轻易被释放。如果这个单例比较大就会吃掉很多内存资源，甚至引起崩溃。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/2016-09-04-design-pattern-overview/" itemprop="url">
                  设计模式概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T10:49:34-04:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。<br>提到设计模式不得不提《设计模式：可复用面向对象软件的基础》（Design Patterns – Elements of Reusable Object-Oriented Software） 一书。这本书由著名的四人帮——GoF(Gang of Four)编写，其中总结了23种设计模式，并将他们分成几个大类。</p>
<p><strong>设计模式的六大原则</strong></p>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong><br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong><br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。<br>其中前四种也是面向对象的四个基本原则。</p>
<p><strong>设计模式分类</strong></p>
<p>设计模式分为三种类型，共23种。<br><strong>创建型模式：</strong>单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br><strong>结构型模式：</strong>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br><strong>行为型模式：</strong>模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>
<p><strong>23种设计模式简单介绍</strong></p>
<p>按字典序排列简介如下。<br><strong>Abstract Factory（抽象工厂模式）：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>Adapter（适配器模式）：</strong>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br><strong>Bridge（桥接模式）：</strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br><strong>Builder（建造者模式）：</strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>Chain of Responsibility（责任链模式）：</strong>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。<br><strong>Command（命令模式）：</strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。<br><strong>Composite（组合模式）：</strong>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。<br><strong>Decorator（装饰模式）：</strong>动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。<br><strong>Facade（外观模式）：</strong>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>Factory Method（工厂模式）：</strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。<br><strong>Flyweight（享元模式）：</strong>运用共享技术有效地支持大量细粒度的对象。<br><strong>Interpreter（解析器模式）：</strong>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。<br><strong>Iterator（迭代器模式）：</strong>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。<br><strong>Mediator（中介模式）：</strong>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>Memento（备忘录模式）：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。<br><strong>Observer（观察者模式）：</strong>定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。<br><strong>Prototype（原型模式）：</strong>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。<br><strong>Proxy（代理模式）：</strong>为其他对象提供一个代理以控制对这个对象的访问。<br><strong>Singleton（单例模式）：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。<br><strong>State（状态模式）：</strong>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。<br><strong>Strategy（策略模式）：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。<br><strong>Template Method（模板方法模式）：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>Visitor（访问者模式）：</strong>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p><strong>23种设计模式之间的关系</strong></p>
<img src="/2016/09/04/2016-09-04-design-pattern-overview/design-pattern.jpg" alt="design-pattern.jpg" title="">

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/2016-8-31-fenng/" itemprop="url">
                  也谈两句fenng的事
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T08:55:29-04:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近圈里一个热门话题是一个丁香园的员工深扒fenng作为CTO如何失职。fenng对此也做了专门回应。看完双方的原帖后。有一点事情貌似两个人都没有异议：</p>
<p>那就是fenng不具备写代码的能力。</p>
<p>OK，我以为事情到这里已经很明了了，没想到竟然引发无数网友对于CTO到底要不要会写代码的激烈讨论。甚至有一帮人理直气壮大有一番“当CTO就是不会写怎么滴”的架势。</p>
<p>我们先从体育说起，比如足球、篮球、排球等等运动，教练员一般分为两派：运动员转型或者学院出身。但不管什么派别，作为一个运动参与者，没有一定程度的训练经历是不可能非常深刻地理解一项运动的，所谓的“一定程度”，可以理解为自己参与过专业教练的训练，而且长期对训练和比赛过程有一手观察和记录，最好有专业师傅带着。而这里，所谓的“非运动员出身”，只不过是没有打过TA将要执教的专业级别的比赛而已，并不是完全没有参与过这项运动。虽然他身体的硬件条件和运动天赋不够成为优秀的运动员。但是如果有足够的悟性还是可以成为一名好教练。</p>
<p>同理，要能成为一名优秀的技术领导者，没有一定程度的实践经验是不行的。写代码用的是脑袋和手指，只要这几个器官功能还正常，花时间精力去研究技术，都能写好代码。当上技术领导者以后，可以不参与编程的具体工作，但是还是要有足够的技术直觉，即敏锐察觉出技术的薄弱环节，知道哪些事情的轻重缓急，知道技术应该往哪个方向发展。这些能力，没有几年的实践经验做累积是根本不能具备的。在这个写代码出身的CEO一抓一大把的年代，还在讨论CTO是不是要会写代码，真是可笑。</p>
<p>fenng的文笔很不错，也给丁香园做了很好的宣传，但是在我看来，他作为CTO就是水货，</p>
<p>这让我想起了亲身经历过的另一个水货CTO。美国最顶级名校，几百篇论文发表，各种大公司头衔，你到youtube上一搜可以搜出长串他的演讲。当初公司没经验，重金把他招来做CTO。来了慢慢发现,大事不妙，这货真是技术小白，用一个新词形容最为恰当“首席产品体验师”＋“首席邮件挑错师”.他把公司有限的人力资源浪费在无休止的折腾上，几个月来公司技术层面几乎止步不前。幸好，CEO是个明眼人，当机立断把他炒了。从这件事学的几点教训：</p>
<ol>
<li>CTO是可选项，并非一个公司的标配。</li>
<li>即使背景看起来很牛逼也并不一定是真牛逼</li>
<li>会写代码的能力是对CTO的起码要求。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/27/first_blog/" itemprop="url">
                  关于本站
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-27T08:55:29-04:00" content="2016-08-27">
              2016-08-27
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>取名乾乾，源于易经“君子终日乾乾”之意。</p>
<p>乾乾，大学毕业于中国科学技术大学，留美硕士。毕业后在美国工作，目前就职于纽约的一家新创软件公司，经历过创业初期的各种颠簸和磨砺，也分享过柳暗花明的喜悦。目前公司已进入一个稳定上升阶段。日常主要专注于移动端开发（iOS和Android）。平时对计算机视觉（computer vision）以及机器学习（machine learning）也有一点研究，有几项专利发明，有一点实践经验，乐于学习和分享技术经验。</p>
<p>这个站点主要是用来纪录一点平时工作学习的心得体会，秉承”独乐乐不如众乐乐”的理念，希望也能对其他人有点用。当然，偶尔也会发表一些对技术圈热点新闻的评论。所有文章仅代表个人观点。</p>
<p>可以通过电子邮件和我联系: manongtalk@gmail.com</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/show_me.jpg"
               alt="乾乾" />
          <p class="site-author-name" itemprop="name">乾乾</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乾乾</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
